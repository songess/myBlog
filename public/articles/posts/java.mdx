---
title: 자바 공부
date: 2025-02-24
excerpt: 스프링을 위한 자바
image: /png/java/250228-205719.png
id: java
category: BE
---

이제 C, js를 어느정도 안다. 그렇다면 java 역시 빠르게 학습할 수 있지 않을까? 스프링을 학습하며 필요한 부분들을 공부하고 정리한다.

# 어노테이션
클래스 위에 `@`를 붙여서 사용한다. 코드에 메타데이터를 제공하는 역할을 한다. 컴파일러에게 정보를 제공한다든지, 런타임에 동적처리를 한다든지, 코드에 정보를 제공하고 검증할 수 있다.

## 메타 어노테이션
어노테이션을 위한 어노테이션. 기간, 범위, 상속여부, 문서화여부를 선택할 수 있다.

## 종류
제공되는 어노테이션도 존재하고, 사용자 정의를 통해 어노테이션을 사용할 수 있다.

# 람다식
js의 화살표 함수이다. 익명함수를 대체할 수 있다.

<br/> 함수형 인터페이스, 즉 하나의 추상 메서드만을 가지고 있는 인터페이스를 필요로 한다. 

# 자료형
js와 비슷하다. 다만 `undefined`, `symbol`이 존재하지 않는다. 그리고 정수, 유리수는 c를 따른다.

원시타입을 참조타입처럼 다루도록하는 `Wrapper`클래스가 존재한다.

# 메서드
자바에서 함수는 클래스 내부에 있는 메서드를 의미한다.

## 인스턴스 메서드
일반적으로 생각하는 메서드

## 추상 메서드
인터페이스 내부에만 사용되는 메서드, 선언부만 존재한다.
### default 메서드
인터페이서의 추상메서드에 초기화파트를 구현할 수 있다. 추상메서드는 오버라이드가 필요한데, 디폴트가 있으면 생략이 가능하다. 

## 정적 메서드
전역변수처럼 생각하면 되고, 객체생성 없이 메서드를 호출할 수 있다. 또한 공유자원으로 쓰인다.
```java
public class MathUtil {
    // static 메서드
    public static int add(int a, int b) {
        return a + b;
    }
}

// 객체 선언없이 사용가능(인스턴스 메서드는 객체를 선언해 꺼내써야 한다)
int result = MathUtil.add(3, 5);
```

## final 메서드
오버라이드가 불가능한 메서드

## synchronized 메서드
여러 쓰레드간 동시 호출이 발생하면 lock처리가 되어 동기화된다. 

# 인터페이스
클래스의 설계 규약. 상태는 선언할 수 없다. ts와 다르게 런타임에도 인터페이스라는 별도의 구조로 인식된다. 즉 OOP 추상화 도구라고 생각하면 된다.

# 리플렉션
리플렉션은 런타임에 클래스, 메서드, 필드 정보를 동적으로 확인하고 접근할 수 있게 해주는 기능이다.

# 스트림
`List`, `Set`등의 자료형을 간결하게 순회할 수 있도록 돕는다.

<br/> 기본적으로 컬렉션에 `filter()`, `map()`등이 제공되지 않기 때문에 for문을 사용해야 하는데, 이를 `stream()`을 사용해 순회할 수 있게 만들어준다.

```java
List<String> names = Arrays.asList("kim", "lee", "park");
names.stream()                // Stream<String> 생성
     .filter(name -> name.startsWith("k"))
     .map(String::toUpperCase)
     .sorted()
     .forEach(System.out::println);
```

# 반환값을 인터페이스로
```java
public List<String> getList() {
    return new ArrayList<>();
}
```
자바에서는 인터페이스를 반환할 수 있다. 추후 `getList()`가 사용하는 함수가 이를 사용할 때 꼭 `ArrayList`일 필요없이 `LinkedList`등으로 사용할 수 있다.

단 `List, Set, Map`등 인터페이스를 반환값으로 설정할 수 있되, 실제 반환은 인터페이스가 아닌 클래스여야 한다.